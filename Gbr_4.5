import numpy as np
import matplotlib.pyplot as plt

# Mengatur gaya plot agar terlihat profesional dan jelas
plt.style.use('seaborn-v0_8-whitegrid')
plt.rcParams['font.family'] = 'serif'
plt.rcParams['figure.dpi'] = 150

# =============================================================================
# 1. FUNGSI-FUNGSI FISIKA
# =============================================================================

def sellemeier_silica(lambda_um):
    """Menghitung indeks bias silika murni (fused silica)."""
    lambda_um_sq = lambda_um**2
    B = [0.6961663, 0.4079426, 0.8974794]
    C_sq = [0.0684043**2, 0.1162414**2, 9.896161**2]
    n_sq = 1.0
    for b_val, c_sq_val in zip(B, C_sq):
        n_sq += (b_val * lambda_um_sq) / (lambda_um_sq - c_sq_val)
    return np.sqrt(n_sq)

def calculate_beta_m(m, wl_m, n0, a_m, delta_m):
    """Menghitung konstanta propagasi beta_m untuk GI-MMF (Pers. 6 dari paper)."""
    k0 = 2 * np.pi / wl_m
    term_in_sqrt = 1 - (2 * np.sqrt(2 * delta_m) / (a_m * k0 * n0)) * (2 * m + 1)
    # Kembalikan 0 jika mode tidak terpandu (cutoff)
    if term_in_sqrt < 0:
        return 0
    return k0 * n0 * np.sqrt(term_in_sqrt)

def calculate_transmission_at_wl(L, wl_m, p):
    """
    Menghitung transmisi P_SM pada satu titik panjang gelombang menggunakan model fisika.
    """
    a_s, delta_s, a_m, delta_m, num_modes = p
    wl_um = wl_m * 1e6

    # Perhitungan parameter yang bergantung pada panjang gelombang
    n_cl_s = sellemeier_silica(wl_um)
    n_co_s = n_cl_s / np.sqrt(1 - 2 * delta_s)
    NA_s = np.sqrt(n_co_s**2 - n_cl_s**2)
    V_s = (2 * np.pi * a_s / wl_m) * NA_s
    
    V_clipped = np.clip(V_s, 0.8, 2.5) # Mencegah error di luar rentang valid Marcuse
    ws_over_a = 0.65 + 1.619 / (V_clipped**1.5) + 2.879 / (V_clipped**6)
    w_s = ws_over_a * a_s

    n_cl_m = sellemeier_silica(wl_um)
    n0_m = n_cl_m / np.sqrt(1 - 2 * delta_m)
    V_m = (2 * np.pi * a_m / wl_m) * np.sqrt(n0_m**2 - n_cl_m**2)
    
    if V_m <= 0: return 0
    w_m = a_m * np.sqrt(2 / V_m)

    mu = w_s / w_m
    
    # Perhitungan superposisi koheren
    total_field = 0j
    for m in range(num_modes):
        # Koefisien eksitasi
        if np.isclose(mu, 1.0):
            Am_sq = 1.0 if m == 0 else 0.0
        else:
            term1 = (2 * mu) / (1 + mu**2)
            term2 = (1 - mu**2) / (1 + mu**2)
            Am_sq = (term1**2) * (term2**(2*m))

        # Konstanta propagasi
        beta = calculate_beta_m(m, wl_m, n0_m, a_m, delta_m)
        
        # Jumlahkan hanya mode yang terpandu
        if beta > 0:
            total_field += Am_sq * np.exp(-1j * beta * L)
            
    return np.abs(total_field)**2

# =============================================================================
# 2. PARAMETER SIMULASI 
# =============================================================================
# Parameter serat
fiber_params = [
    2.2e-6,      # a_s: Radius inti SMF (meter)
    0.002379,    # delta_s: Perbedaan indeks relatif SMF
    25.0e-6,     # a_m: Radius inti MMF (meter)
    0.008,       # delta_m: Perbedaan indeks relatif MMF
    15           # num_modes: Jumlah mode yang disimulasikan (cukup untuk konvergensi)
]

# PERBAIKAN UTAMA: Menggunakan panjang MMF yang lebih pendek
# untuk "memperlambat" osilasi spektrum agar dapat divisualisasikan.
L0 = 0.042        # Panjang target 4.0 mm
delta_L = 20e-6   # Variasi panjang 0.02 mm (20 mikrometer)
lengths_to_test = [L0 - delta_L, L0, L0 + delta_L]

# Rentang panjang gelombang yang difokuskan
wavelengths_m = np.linspace(1.5e-6, 1.6e-6, 501) # 1500 - 1600 nm

# =============================================================================
# 3. PERHITUNGAN SPEKTRUM TRANSMISI
# =============================================================================
results_loss = {}
for length in lengths_to_test:
    # Mengonversi panjang ke mm hanya untuk label pencetakan
    print(f"Menghitung spektrum untuk L = {length*1000:.2f} mm...")
    
    transmission_spectrum = [calculate_transmission_at_wl(length, wl, fiber_params) for wl in wavelengths_m]
    T_arr = np.array(transmission_spectrum)
    
    # Konversi ke loss dalam dB, hindari log(0)
    loss_db = 10 * np.log10(T_arr, where=(T_arr > 1e-9), out=np.full_like(T_arr, 90.0))
    results_loss[length] = loss_db

print("Perhitungan selesai.")

# =============================================================================
# 4. VISUALISASI HASIL UNTUK GAMBAR 4.5
# =============================================================================
fig, ax = plt.subplots(1, 1, figsize=(10, 6))

# Definisi gaya plot
colors = ['royalblue', 'black', 'firebrick']
styles = ['--', '-', '--']
labels = [
    f'L = {lengths_to_test[0]*1000:.2f} mm (-0.02 mm)',
    f'L = {lengths_to_test[1]*1000:.2f} mm (Target)',
    f'L = {lengths_to_test[2]*1000:.2f} mm (+0.02 mm)'
]

# Plot setiap hasil simulasi
for i, length in enumerate(lengths_to_test):
    ax.plot(wavelengths_m * 1e9, results_loss[length],
            color=colors[i],
            linestyle=styles[i],
            lw=2,
            label=labels[i])



# Pengaturan label, judul, dan grid
ax.set_title('Simulasi Toleransi Fabrikasi untuk SMS GI-MMF', fontsize=14, weight='bold')
ax.set_xlabel('Panjang Gelombang (nm)', fontsize=12)
ax.set_ylabel('Coupling Loss (dB)', fontsize=12)
ax.grid(True, linestyle=':', which='both')
ax.legend(title='Panjang MMF', fontsize=10)

# Mengatur batas sumbu untuk tampilan yang optimal
ax.set_xlim(1500, 1600)
ax.set_ylim(-10, 0)

plt.tight_layout()
plt.savefig("gambar_4_5_real_model_final.png", dpi=300)
plt.show()
